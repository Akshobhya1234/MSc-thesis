\chapter{Agda}
Agda is a dependently typed programming language based on unified theory of
dependent types and is an extension of Martin-Löf type theory. Agda allows
programmers to define types that depend on values, to write functions that
utilize these types, and to prove the correctness of the program in the same
language. Agda has been used in various applications such as formal
verification, program synthesis, theorem proving, and automated reasoning. It is
also used by researchers and academician to teach and explore the concepts of
functional programming, type theory, and formal methods.

Agda is also a proof assistant system. Agda is designed to help programmers to
write and verify correct and efficient programs by allowing them to express
their intentions in a precise and formal way. One of the key features of Agda is
its support for interactive, and constructive programming. Interactive
programming allows the programmer to incrementally develop and refine their
code, by testing and verifying each intermediate step. Agda is a constructive
formal system, it ensures that every expression and function in the language has
a well-defined meaning and computation rules, which makes it easier to reason
about their behavior and correctness. This chapter provides a brief overview of
programming in Agda in the context of algebraic structures. 

\section{Types and functions}
\label{types}
Agda is based on a core language that provides a minimal set of primitives and
types, and is extended with libraries and modules that define more complex data
structures, algorithms, and abstractions. Agda's type system allows for the
definition of new types and operations that are tailored to the specific needs
of a particular application or domain. Agda supports inductive types, simple
types, and parameterized types \cite{10.1007/978-3-642-03359-9_6}. A data type
in Agda can be declared using the keyword \inline{data}. Let us consider an
example of inductive datatype to define natural numbers \inline{Nat}.

\label{code:Nat}
\begin{minted}[breaklines,samepage]{Agda}
data Nat : Set where
  zero : Nat
  suc  : Nat -> Nat
\end{minted}

An inductive datatype is a datatype that is defined in terms of itself. In the
code snippet \ref{code:Nat}, \inline{Nat} is an inductive type defined with base
constant \inline{zero} and an inductive data constructor \inline{suc}.
\inline{zero} and \inline{suc} are constructors, where \inline{suc} has a
parameter of type \inline{Nat} and \inline{zero} has no parameters. In this
example, the smallest element is \inline{zero}. Another way of defining a type
is using the keyword \inline{record}. A record type can be defined by
referencing other types and creating a synonym. An example of record type is
discussed later in the chapter when we define algebraic structure.

Those familiar with Haskell will find Agda to be somewhat familiar. For example,
functions have a very similar syntax to those in Haskell. A function in Agda is
defined by declaring the type followed by the clauses.

\begin{minted}[breaklines,samepage]{Agda}
f : (x₁ : A₁) → ... → (xₙ : Aₙ) → B
f p₁ ... pₙ = d
...
f q₁ ... qₙ = e
\end{minted} 
Where \inline{f} is the function identified, \inline{p} and \inline{q} are the
patterns of type \inline{A}. \inline{d} and \inline{e} are expressions. There
are other ways to define a function such as using dot patterns, absurd patterns,
as patterns and case trees. In Agda, a function to and from each type is
provided if there is a bijection between two types.

For example, we can define addition on natural numbers as a recursive function:

\label{code:Add}
\begin{minted}[breaklines,samepage]{Agda}
_+_ : Nat -> Nat -> Nat
zero + m = m
suc n + m = suc (n + m)
\end{minted}

In the above example, function \inline{_+_} takes two arguments of type
\inline{Nat} and returns a value that is sum of the two arguments of type
\inline{Nat}. A recursive call must be made on a structurally smaller argument.
For the function \inline{_+_} above, the first argument \inline{n} is smaller in
the recursive call \inline{suc n}. 

\section{Structure definition}
Let us first understand how unary and binary operations are defined in the Agda
standard library. Below code shows how unary operations \inline{Op₁} and binary
operation \inline{Op₂} are defined:

\begin{minted}[breaklines,samepage]{Agda}
Op₁ : ∀ {ℓ} → Set ℓ → Set ℓ
Op₁ A = A → A
\end{minted}
\begin{minted}[breaklines,samepage]{Agda}
Op₂ : ∀ {ℓ} → Set ℓ → Set ℓ
Op₂ A = A → A → A
\end{minted}

In Agda, not every type belongs to \inline{Set}. Every type belongs somewhere in
the hierarchy \inline{Set₀}, \inline{Set₁}, \inline{Set₂}, and so on.
\inline{Set} abbreviates \inline{Set₀}, and \inline{Set₀ : Set₁}, \inline{Set₁ :
Set₂}, and so  \cite{plfa22.08}. This definition works if we are comparing two
values of some type in \inline{Set}. But, we cannot compare two values that
belong to \inline{Set ℓ} for some arbitrary \inline{ℓ}. To solve this problem,
Agda provides type \inline{Level}. This type helps us to define equality
generalized to an arbitrary level.

To understand how two terms are compared, let us first understand equality.
Equality says that two things are "equal". But asking "when two things are
equal" is non trivial. In \cite{musa}, a hierarchy of "sameness" is given.
\begin{enumerate}
  \item For some symbol $t_1 \text{and} t_2$, $t_1 = t_2$ if $t_1 and t_2$ are
literally the same symbols. This is called synctatic equality.
  \item Definitional equality says that $t_1 = t_2$ when solving one symbol by
  applying some definitions leads to synctatic equality.
  \item In Propositional equality, if we need to say two symbols $t_1$ and $t_2$
  are equal $(t_1 \equiv t_2)$, then one must perform induction to arrive at
  definitional equality.
  \item For symbols $t_1$ and $t_2$, $t_1 \approx t_2$ is true if \inline{_≈_} is
  an equivalence relation.
\end{enumerate}  

In Agda, propositional equality $(\_ \equiv\_ )$ is defined for a type $A$ and an
element $x \in A$ with a constructor \inline{refl} that provides evidence that
$x \equiv x$. From this definition of equality, we can prove that it is an
equivalence relation. However, in practice, this definition of propositional
equality is too strong and one prefers to use a finer equivalence relation
\cite{musa}. 

An algebraic structure can be defined in Agda as a record type using the
\inline{record} keyword. The record type allows to have parameters immediately
after the record's name declaration or may be declared with \inline{field}
keyword. The structures are obtained by wrapping the predicates that are
expressed as "is-a" relation \cite{hu2021formalizing}. The types of algebraic
structures are defined in module \inline{Algebra.Structures} that have an
underlying set \inline{A} and the homogeneous binary relation \inline{_≈_}. The
types of algebraic structures are defined over the setoid, i.e., set equipped
with equivalence relation. 

\begin{minted}[breaklines,samepage]{Agda}
module Algebra.Structures
  {a ℓ} {A : Set a} 
  (_≈_ : Rel A ℓ)    
  where
\end{minted}

The module declaration is treated as a top-level function that take the
parameters of module as arguments. The parameters can be values and types but
not other modules.

The following example shows how to characterize magma
structures in Agda:
\begin{minted}[breaklines,samepage]{Agda}
record IsMagma (∙ : Op₂ A) : Set (a ⊔ ℓ) where
  field
    isEquivalence : IsEquivalence _≈_
    ∙-cong        : Congruent₂ ∙

  open IsEquivalence isEquivalence public
\end{minted}

In the above example, structure \inline{IsMagma} is defined as a record type
with a parameter \inline{Op₂ A}. The properties of the structure
\inline{IsMagma} are declared as the fields of the record, which include
equivalence \inline{isEquivalence} and congruence \inline{∙-cong}. \inline{∙} is
a binary operation on the set \inline{A}. \inline{a ⊔ ℓ} gives the largest of
two levels. \inline{_≈_} is the binary operation argument for
\inline{IsEquivalence}. \inline{IsEquivalence} and \inline{Congruent₂} are
predicates defined in standard library. We open the module
\inline{isEquivalence} to bring its definition into scope. The open statement is
made public using the keyword \inline{public} to be able to re-export the names
from another module.

The bundled version of the structures contains the operations of the structures,
sets and axioms. The structures are imported from "Algebra.Structures" so we can
parameterize the definitions with equality that is used to compare the terms of
the structure.

\begin{minted}[breaklines,samepage]{Agda}
record Magma c ℓ : Set (suc (c ⊔ ℓ)) where
  infixl 7 _∙_
  infix  4 _≈_
  field
    Carrier : Set c
    _≈_     : Rel Carrier ℓ
    _∙_     : Op₂ Carrier
    isMagma : IsMagma _≈_ _∙_

  open IsMagma isMagma public

  rawMagma : RawMagma _ _
  rawMagma = record { _≈_ = _≈_; _∙_ = _∙_ }

  open RawMagma rawMagma public
    using (_≉_)
\end{minted}

Above is the bundled version of \inline{IsMagma} structure. \inline{RawMagma} is
the raw version of the magma with only the operators and set. infix<l,r> denotes
the fixity and precedence of the operator. \inline{_≈_} defines equality used to
compare terms of \inline{Magma}. The operator with higher fixity binds more
strongly than an operator with a lower numeric value. \inline{using} keyword is
used to limit the imported components. When exporting the modules, we may need
to rename the fields to avoid having ambiguity. Keyword \inline{renaming} is
used to rename the fields.

\label{code:rename}
\begin{minted}[breaklines,samepage]{Agda}
  open IsMagma *-isMagma public
    using ()
    renaming
    ( ∙-congˡ  to *-congˡ
    ; ∙-congʳ  to *-congʳ
    )
\end{minted} 

We rename \inline{∙-congˡ}  to \inline{*-congˡ} and \inline{∙-congʳ}  to
\inline{*-congʳ} thus avoiding conflict with same elements exported by other
module.

\section{Morphism in Agda}
A homomorphism is a structure preserving map between two structures. A
homomorphism for two magma structures is defined as a record type:
\begin{minted}[breaklines,samepage]{Agda}
module MagmaMorphisms (M₁ : RawMagma a ℓ₁) (M₂ : RawMagma b ℓ₂) where

  open RawMagma M₁ renaming (Carrier to A; _≈_ to _≈₁_; _∙_ to _∙_)
  open RawMagma M₂ renaming (Carrier to B; _≈_ to _≈₂_; _∙_ to _◦_)

  record IsMagmaHomomorphism (⟦_⟧ : A → B) : Set (a ⊔ ℓ₁ ⊔ ℓ₂) where
  field
    isRelHomomorphism : IsRelHomomorphism _≈₁_ _≈₂_ ⟦_⟧
    homo              : Homomorphic₂ ⟦_⟧ _∙_ _◦_

  open IsRelHomomorphism isRelHomomorphism public
    renaming (cong to ⟦⟧-cong)
\end{minted}

The \inline{raw structures}, in the above example, \inline{RawMagma} is the
definition of signature the structure. \inline{IsMagmaHomomorphism} is a record
type with fields \inline{isRelHomomorphism} and \inline{homo}. Since the
formalization of the types of algebraic structures in Agda is based on setoid,
\inline{IsRelHomomorphism} is defined for homomorphism between the homogeneous
equivalence relations \inline{_≈₁_} and \inline{_≈₂_}. \inline{Homomorphic₂} is
defined for two binary operations as:
\begin{minted}[samepage,breaklines]{Agda}
Homomorphic₂ : (A → B) → Op₂ A → Op₂ B → Set _
Homomorphic₂ ⟦_⟧ _∙_ _∘_ = ∀ x y → ⟦ x ∙ y ⟧ ≈ (⟦ x ⟧ ∘ ⟦ y ⟧)
\end{minted}

From this definition of homomorphism, monomorphism of the structure is given as:

\begin{minted}[breaklines,samepage]{Agda}
  record IsMagmaMonomorphism (⟦_⟧ : A → B) : Set (a ⊔ ℓ₁ ⊔ ℓ₂) where
  field
    isMagmaHomomorphism : IsMagmaHomomorphism ⟦_⟧
    injective           : Injective ⟦_⟧

  open IsMagmaHomomorphism isMagmaHomomorphism public
\end{minted}
\inline{IsMagmaMonomorphism} is defined as a record type with field
\inline{isMagmaHomomorphism} and \inline{injective}. The \inline{Injective}
function is a one to one map defined as:
\begin{minted}[samepage,breaklines]{Agda}
Injective : (A → B) → Set (a ⊔ ℓ₁ ⊔ ℓ₂)
Injective f = ∀ {x y} → f x ≈₂ f y → x ≈₁ y
\end{minted}
where \inline{_≈₁_} is the equality over the domain \inline{A} and \inline{_≈₂_}
is the equality over codomain \inline{B}.

Isomorphism of a structure can be derived from monomorphism with surjectivity.
\begin{minted}[samepage,breaklines]{Agda}
record IsMagmaIsomorphism (⟦_⟧ : A → B) : Set (a ⊔ b ⊔ ℓ₁ ⊔ ℓ₂) where
  field
    isMagmaMonomorphism : IsMagmaMonomorphism ⟦_⟧
    surjective          : Surjective ⟦_⟧

  open IsMagmaMonomorphism isMagmaMonomorphism public
\end{minted} 
\inline{IsMagmaIsomorphism} is defined as a record type with field
\inline{isMagmaMonomorphism} and \inline{surjective}. A surjective relation
requires equality (\inline{_≈₂_}) on the codomain \inline{B} and is defined as:
\begin{minted}[samepage,breaklines]{Agda}
Surjective : (A → B) → Set (a ⊔ b ⊔ ℓ₂)
Surjective f = ∀ y → ∃ λ x → f x ≈₂ y
\end{minted}

\section{Direct Product in Agda}
For two algebra $A$ and $B$ of the same theory with set $S_A$ and $S_B$
respectively, the product of algebra is defined with carrier set $(S_A \times
S_B)$ and for each operation $f$ in the theory is defined as:
\[f\ (x_{1_A},x_{1_B})...(x_{n_A},x_{n_B}) = (f_A\ x_{1_A}...x_{n_b}\ ,\ f_B\
x_{1_B},x_{n_B} )\] where $x_{1_A},...,x_{n_B}$ are elements in $S_A$ and
$x_{1_B},...,x_{n_B}$ are elements in $S_B$. The direct products of structures
are defined in \inline{Algebra.Construct.DirectProducts} in Agda standard
library. The direct product of magma structure is defined as:
\begin{minted}[breaklines,samepage]{Agda}
magma : Magma a ℓ₁ → Magma b ℓ₂ → Magma (a ⊔ b) (ℓ₁ ⊔ ℓ₂)
magma M N = record
  { Carrier = M.Carrier × N.Carrier
  ; _≈_     = Pointwise M._≈_ N._≈_
  ; _∙_     = zip M._∙_ N._∙_
  ; isMagma = record
    { isEquivalence = ×-isEquivalence M.isEquivalence N.isEquivalence
    ; ∙-cong = zip M.∙-cong N.∙-cong
    }
  } where module M = Magma M; module N = Magma N
\end{minted}
where \inline{Magma} is the bundled version of the magma structure. The carrier
set for direct product of \inline{M} and \inline{N} is the product $M \times N$.
\inline{Pointwise} gives the product of relations (\inline{_≈_}) in \inline{M}
and \inline{N}. \inline{zip} gives a $\Sigma$-type of dependent pairs.
\inline{×-isEquivalence} is the product of equivalence relations in \inline{M}
and \inline{N}.

\section{Calculational Proofs in Agda}
A proof is a sequence of steps that transform one expression into another using
a set of rules. Agda allows us to declare properties of functions and data types
that need to be verified by the compiler. \cite{kidney2020finiteness}.  

In the section \ref{types}, we have seen how to define natural number and addition
function on it. Now, we will write an inductive proof using pattern matching
that states that the addition of two natural numbers is commutative.

\begin{minted}[breaklines,samepage]{Agda}
comm : ∀ (m n : Nat) → m + n ≡ n + m
comm zero zero = refl
comm zero (suc n) = cong suc (comm zero n)
comm (suc m) n = cong suc (comm m n)
\end{minted}

In the above example, the proof \inline{comm zero zero} represents commutative
property where both \inline{m} and \inline{n} are \inline{zero}. The
\inline{refl} function is used to prove that two expressions are equal using the
reflexivity of equality. \inline{comm zero suc n} and \inline{suc m + n} are
reduced recursively until the base case is reached. The \inline{cong} function
is used to apply the inductive hypothesis to the successive \inline{suc}
constructors. This is just a simple example of proof, but Agda allows us to
express and verify more complex properties, such as type soundness, termination,
and correctness of algorithms.

In algebraic structure, consider the example to the proposition of the
associative property x ∙ (y ∙ z) = (x ∙ y) ∙ z  for a semigroup i.e., a Magma
with associative property (x ∙ (y ∙ z) = (x ∙ y) ∙ z). The proof can be written
in Agda as:
\begin{minted}[breaklines,samepage]{Agda}
x∙yz≈xy∙z : ∀ x y z → x ∙ (y ∙ z) ≈ (x ∙ y) ∙ z
x∙yz≈xy∙z x y z = begin 
  x ∙ (y ∙ z) ≈⟨ sym (assoc x y z) ⟩ 
  (x ∙ y) ∙ z ∎
\end{minted}
To make proofs more readable, people have tried to emulate textual proofs, for
example, by creating "begin" and "end" syntax. \inline{begin} indicates the start
of the proof. \inline{begin} is a function that relates two objects.
\begin{minted}{Agda}
begin_ : ∀ {x y} → x IsRelatedTo y → x ∼ y
begin relTo x∼y = x∼y
\end{minted}
\inline{IsRelatedTo} is a type defined to infer arguments even if the underlying equality
evaluates. Standard step to relation is defined as \inline{step-∼}.
\begin{minted}[breaklines,samepage]{Agda}
step-∼ : ∀ x {y z} → y IsRelatedTo z → x ∼ y → x IsRelatedTo z
step-∼ _ (relTo y∼z) x∼y = relTo (trans x∼y y∼z)
\end{minted}
similarly, step using equality is given as
\begin{minted}[breaklines,samepage]{Agda}
step-≈ = Base.step-∼
syntax step-≈ x y≈z x≈y = x ≈⟨ x≈y ⟩ y≈z
\end{minted}
The termination (i.e., QED) of the proof is given using \inline{_∎} that relates object to itself.
\begin{minted}[breaklines,samepage]{Agda}
_∎ : ∀ x → x IsRelatedTo x
x ∎ = relTo refl
\end{minted}
Agda supports quantifiers. Universal quantifier is denoted as \(\forall\) and
existential quantifier is denoted as \(\exists\).

