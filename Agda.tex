\chapter{Agda}
Agda is a dependently typed programming. Agda is pure in the sense that the
functions have no effect and does not use state. Agda uses lazy evaluation. That
is the expressions are not evaluated until they are needed. Therefore, in Agda,
the order of evaluation is hard to predict. Strict evaluation is to evaluate all
arguments to the function before evaluating the function. Since Agda is lazy,
both strict and lazy evaluation will give the same output
\cite{kidney2020finiteness} Agda is total. A function in agda gives output in a
finite amount of time for a valid input.\\
The process of validating and imposing constraints on values is called type
checking. Agda can be compiled to haskell or javascript but it is only type
checked, so it can be used as a proof assistant. Agda is based on unified theory
of dependent types \cite{enwiki:1127496533} hence the program written in Agda is
in line with the Martin-Löf Type Theory \cite{kidney2020finiteness}. This
chapter provides a brief overview of programming in Agda in the context of
algebraic structures. 

\section{Types and functions}
Agda provides logical framework in the sense that the core of Agda provides a
framework that gives the type Set and dependent functions (x : A)
\(\rightarrow\) B. Agda supports inductive
types.\cite{10.1007/978-3-642-03359-9_6}. Agda provides simple types and
parameter types. These data types are declared using the keyword data.

\begin{minted}{Agda}
data Nat : Set where
  zero : Nat
  suc  : Nat -> Nat
\end{minted}

In the above example, \inline{Nat} is the data type that has two constructors \inline{zero} and
\inline{suc}. Constructor are used to assign values to the variables in the type. This
type is called inductive type. In this example, the smallest set is a set
containing an element \inline{zero} and is closed under the function \inline{suc}. Since the
properties of this function can be proved inductively, the type is called
inductive type\cite{enwiki:1127496533}. The datatype can have parameters
and	can be indexed.  
Another way of defining a type is using the keyword \inline{record}. A record type can be
defined by referencing other types and creating a synonym. An example of record
type is discussed later in the chapter when we define the algebraic structure.\\
Since types are values in Agda, there is no real way to distinguish between
them. If \inline{bool} is a simple type or type\textsubscript{0}, then what is the type
of type\textsubscript{0}? Note that this is similar to the Rusell's paradox that
is discussed in previous chapter. Agda uses universe polymorphism to resolve
this issue. That is the type of \inline{true} is Bool and its type is
type\textsubscript{0}. The type of  type\textsubscript{0} is
type\textsubscript{1} and so on. \cite{kidney2020finiteness}.\\
Similarly, in Agda not every type is a set and the set type can be defined using
keyword Set\textsubscript{1}. "A type whose elements are types are called
universe" \cite{universeagda}. This primitive type is useful to define and prove
theorems about functions that operate on large set.\\

The functions in Agda are very similar to function in Haskell. A function in Agda
is defined by declaring the type followed by the clauses \cite{agdaFunction}. 
\begin{minted}{Agda}
f : (x₁ : A₁) → … → (xₙ : Aₙ) → B
f p₁ … pₙ = d
…
f q₁ … qₙ = e
\end{minted} 
Where f is the function identified, p\textsubscript{i} and q\textsubscript{i}
are the patterns of type A\textsubscript{i}. d and e are expressions. The agda
documentation discuss other techniques to define a function such as using dot
patterns, absurd patterns, as patterns and case trees \cite{agdaFunction}.\\

An operator in agda is also defined as a function. Underscore is used to
indicate where an argument is expected. For example, \inline{and} operator can be defined as 
\begin{minted}{Agda}
_and_ : Bool → Bool → Bool
true and x = x
false and _ = false
\end{minted}

In context of algebra, agda defines unary \inline{Op₁} and binary
\inline{Op₂} operations.
\begin{minted}{Agda}
Op₁ : ∀ {ℓ} → Set ℓ → Set ℓ
Op₁ A = A → A
\end{minted}
\begin{minted}{Agda}
Op₂ : ∀ {ℓ} → Set ℓ → Set ℓ
Op₂ A = A → A → A
\end{minted}

\section{Structure definition}
Algebraic structures are defined as record types in Agda. Records types are used
to group values together, and they provide named fields to generalize dependent
product types. The structures are obtained by wrapping the predicates that are
expressed as \inline{is-a} relation. ~\citep{hu2021formalizing}
\begin{minted}{Agda}
record IsMagma (∙ : Op₂ A) : Set (a ⊔ ℓ) where
  field
    isEquivalence : IsEquivalence _≈_
    ∙-cong        : Congruent₂ ∙

  open IsEquivalence isEquivalence public
\end{minted}
In the above example structure \inline{IsMagma} is defined as a record type with
fields \inline{isEquivalence} and \inline{∙-cong}. \inline{∙} is a binary
operation on set \inline{A}. \inline{a ⊔ ℓ} is the least upper bound for the
set. \textunderscore  ≈ \textunderscore is the binary operation argument for
\inline{IsEquivalence}. If a relation P on set A is equivalent to relation Q on
set B, then we say f preserves p for some map f from set A to B.
\inline{Congruent₂ ∙} represents that the binary operation ∙ preserves
equivalence relation. \inline{IsEquivalence} and \inline{Congruent₂} are
predicates defined in standard library.\\
We open the module \inline{isEquivalence} to be able to use it in defining other
structures in the algebra hierarchy. The open statement is made public using the
keyword \inline{public} to be able to re-export the names from another module.
Morphisms of the structure are defined as record type in Agda standard library
and the example are shown in Chapter 5.

Agda standard library defines the bundled version of the structures that
contains the operations of the structures, sets and axioms. 
\begin{minted}{Agda}
record Magma c ℓ : Set (suc (c ⊔ ℓ)) where
  infixl 7 _∙_
  infix  4 _≈_
  field
    Carrier : Set c
    _≈_     : Rel Carrier ℓ
    _∙_     : Op₂ Carrier
    isMagma : IsMagma _≈_ _∙_

  open IsMagma isMagma public

  rawMagma : RawMagma _ _
  rawMagma = record { _≈_ = _≈_; _∙_ = _∙_ }

  open RawMagma rawMagma public
    using (_≉_)
\end{minted}
Above is the bundled version of \inline{IsMagma} structure. \inline{RawMagma} is
the raw version of the magma with only the operators and set. infix<l,r> denotes
the fixity and precedence of the operator. \inline{using} keyword is used to
export only the fields that are mentioned in its arguments. When exporting the
modules we may need to rename the fields to avoid having duplicate names.
\begin{minted}{Agda}
  open IsMagma *-isMagma public
    using ()
    renaming
    ( ∙-congˡ  to *-congˡ
    ; ∙-congʳ  to *-congʳ
    )
\end{minted} 
Keyword \inline{renaming} is used to rename the fields. In the above sample code, we
rename \inline{∙-congˡ}  to \inline{*-congˡ} and \inline{∙-congʳ}  to \inline{*-congʳ}.

\subsection{Equational Proofs in Agda}
In the Russell's paradox discussed in the previous sections, if a theorem is to
be proved, we need to use the axiom that is the theorem itself. To overcome this
Dutch mathematician L. E. J. Brouwer discovered intuitionism that led to
constructive mathematics \cite{enwiki:1122615242}. In constructive mathematics,
knowledge comes with implicit arguments. Constructive proofs use the existence
of a mathematical object is given by giving a way to create the method.
\cite{enwiki:1090644431}. In agda, a function to and from each type is
provided if there is a bijection between two types. Dependently typed language
agda thus allow to compile and run proofs \cite{kidney2020finiteness}.  
In Agda, \inline{begin} is used to indicate the start of the proof. \inline{begin} is a
function that relates two objects. 
\begin{minted}{Agda}
begin_ : ∀ {x y} → x IsRelatedTo y → x ∼ y
begin relTo x∼y = x∼y
\end{minted}
\inline{IsRelatedTo} is a type defined to infer arguments even if the underlying equality
evaluates. Standard step to relation is defined as \inline{step-∼}
\begin{minted}{Agda}
step-∼ : ∀ x {y z} → y IsRelatedTo z → x ∼ y → x IsRelatedTo z
step-∼ _ (relTo y∼z) x∼y = relTo (trans x∼y y∼z)
\end{minted}
step using equality is given as
\begin{minted}{Agda}
step-≈ = Base.step-∼
syntax step-≈ x y≈z x≈y = x ≈⟨ x≈y ⟩ y≈z
\end{minted}
The termination of the proof is given using \inline{_∎}
\begin{minted}{Agda}
_∎ : ∀ x → x IsRelatedTo x
x ∎ = relTo refl
\end{minted}
Agda supports quantifiers. Universal quantifier is denoted as \(\forall\) and
existential quantifier is denoted as \(\exists\) 

Below is the example to the proposition x ∙ (y ∙ z) = (x ∙ y) ∙ z  for a
semigroup i.e., a Magma with associative property (x ∙ (y ∙ z) = (x ∙ y) ∙ z) 
\begin{minted}{Agda}
x∙yz≈xy∙z : ∀ x y z → x ∙ (y ∙ z) ≈ (x ∙ y) ∙ z
x∙yz≈xy∙z x y z = begin 
  x ∙ (y ∙ z) ≈⟨ sym (assoc x y z) ⟩ 
  (x ∙ y) ∙ z ∎
\end{minted}
In the proposition x y z are in set S that is a semigroup. \inline{sym (assoc x y z)}
is the reasoning for the proof. 

