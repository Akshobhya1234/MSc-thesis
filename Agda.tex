\chapter{Agda}
Agda is a dependently typed programming language based on unified theory of
dependent types and is an extension of Martin-Löf type theory. Dependent
programming allows programmers to define types that depend on values, to write
functions that utilize these types, and to prove the correctness of the program
in the same language. In other words, dependent type theory allow types to
depend on values and expressions. Agda has been used in various applications
such as formal verification, program synthesis, theorem proving, and automated
reasoning. It is also used by researchers and academician to teach and explore
the concepts of functional programming, type theory, and formal methods.

Agda is also a proof assistant system. Agda is designed to help programmers to
write and verify correct and efficient programs by allowing them to express
their intentions in a precise and formal way. One of the key features of Agda is
its support for interactive, and constructive. Interactive programming allows
the programmer to incrementally develop and refine their code, by testing and
verifying each intermediate step. Agda is a constructive formal system, it
ensures that every expression and function in the language has a well-defined
meaning and computation rules, which makes it easier to reason about their
behavior and correctness. This chapter provides a brief overview of programming
in Agda in the context of algebraic structures. 

\section{Types and functions}
Agda is based on a core language that provides a minimal set of primitives and
types, and is extended with libraries and modules that define more complex data
structures, algorithms, and abstractions. Agda's type system allows for the
definition of new types and operations that are tailored to the specific needs
of a particular application or domain. Agda supports inductive types, simple
types, and parameterized types \cite{10.1007/978-3-642-03359-9_6}. A data type
in Agda can be declared using the keyword \inline{data}. Let us consider an
example of inductive datatype to define natural numbers \inline{Nat}.
\label{code:Nat}
\begin{minted}[breaklines,samepage]{Agda}
data Nat : Set where
  zero : Nat
  suc  : Nat -> Nat
\end{minted}

An inductive datatype is a datatype that is defined in terms of itself. In the
code snippet \ref{code:Nat}, \inline{Nat} is an inductive type defined with base
constant \inline{zero} and an inductive data constructor \inline{suc}.
\inline{zero} and \inline{suc} are constructors, where \inline{suc} has a
parameter of type (\inline{Nat}) and \inline{zero} has no parameters. In this
example, the smallest element is \inline{zero}. It is important to note that
Agda is a total language, i.e., each program in Agda will
terminate\cite{kidney2020finiteness}. Another way of defining a type is using
the keyword \inline{record}. Record type helps to put values together, and the
values are tuples of values of specified types. A record type can be defined by
referencing other types and creating a synonym. An example of record type is
discussed later in the chapter when we define algebraic structure.

Those familiar with Haskell will find Agda to be somewhat familiar. For example,
functions have a very similar syntax to those in Haskell. A function in Agda is
defined by declaring the type followed by the clauses. 
\begin{minted}[breaklines,samepage]{Agda}
f : (x₁ : A₁) → ... → (xₙ : Aₙ) → B
f p₁ ... pₙ = d
...
f q₁ ... qₙ = e
\end{minted} 
Where \inline{f} is the function identified, \inline{p} and \inline{q} are the
patterns of type \inline{A}. \inline{d} and \inline{e} are expressions. There
are other ways to define a function such as using dot patterns, absurd patterns,
as patterns and case trees. In Agda, a function to and from each type is
provided if there is a bijection between two types.

For example, we can define addition on natural numbers as a recursive function:
\label{code:Add}
\begin{minted}[breaklines,samepage]{Agda}
_+_ : Nat -> Nat -> Nat
zero + m = m
suc n + m = suc (n + m)
\end{minted}

In the above example, function \inline{_+_} takes two arguments of type
\inline{Nat} and returns a value that is sum of the two arguments of type
\inline{Nat}. To guarantee that the program always terminate, a recursive call
in must be made on a structurally smaller argument. For the function
\inline{_+_} above, the first argument \inline{n} is smaller in the recursive
call \inline{suc n}. This ensures that the function \inline{_+_} always
terminates.

\section{Structure definition}
Let us first understand how unary and binary operations are defined in the Agda
standard library. Below code shows how unary operations \inline{Op₁} and binary
operation \inline{Op₂} are defined:
\begin{minted}[breaklines,samepage]{Agda}
Op₁ : ∀ {ℓ} → Set ℓ → Set ℓ
Op₁ A = A → A
\end{minted}
\begin{minted}[breaklines,samepage]{Agda}
Op₂ : ∀ {ℓ} → Set ℓ → Set ℓ
Op₂ A = A → A → A
\end{minted}

In Agda, not every type belongs to \inline{Set}. Every type belongs somewhere in
the hierarchy \inline{Set₀}, \inline{Set₁}, \inline{Set₂}, and so on.
\inline{Set} abbreviates \inline{Set₀}, and \inline{Set₀ : Set₁}, \inline{Set₁ :
Set₂}, and so  \cite{plfa22.08}. This definition works if we are comparing two
values of some type in \inline{Set}. But, we cannot compare two values that
belong to \inline{Set ℓ} for some arbitrary \inline{ℓ}. To solve this problem,
Agda provides type \inline{Level}. This type helps us to define equality
generalized to an arbitrary level.

An algebraic structure can be defined in Agda using the record keyword, which is
used to define a new data type along with its properties. The structures are
obtained by wrapping the predicates that are expressed as "is-a" relation
\cite{hu2021formalizing}.

The types of algebraic structures are defined in module
\inline{Algebra.Structures} that has an underlying set \inline{A} and the
equality relation \inline{_≈_}.
\begin{minted}[breaklines,samepage]{Agda}
module Algebra.Structures
  {a ℓ} {A : Set a} 
  (_≈_ : Rel A ℓ)    
  where
\end{minted}

The following example shows how to characterise magma
structures in Agda:
\begin{minted}[breaklines,samepage]{Agda}
record IsMagma (∙ : Op₂ A) : Set (a ⊔ ℓ) where
  field
    isEquivalence : IsEquivalence _≈_
    ∙-cong        : Congruent₂ ∙

  open IsEquivalence isEquivalence public
\end{minted}
In the above example structure \inline{IsMagma} is defined as a record type with
a parameter \inline{Op₂ A}. The properties of the structure \inline{IsMagma} are
declared as the fields of the record, which include equivalence
\inline{isEquivalence} and congruence \inline{∙-cong}. \inline{∙} is a binary
operation on the set \inline{A}. \inline{a ⊔ ℓ} is the least upper bound for the
set. \inline{_≈_} is the binary operation argument for \inline{IsEquivalence}.
\inline{Congruent₂ ∙} represents that the binary operation ∙ preserves
equivalence relation. \inline{IsEquivalence} and \inline{Congruent₂} are
predicates defined in standard library. We open the module
\inline{isEquivalence} to bring its definition into scope. The open statement is
made public using the keyword \inline{public} to be able to re-export the names
from another module.

The bundled version of the structures contains the operations of the structures,
sets and axioms. 
\begin{minted}[breaklines,samepage]{Agda}
record Magma c ℓ : Set (suc (c ⊔ ℓ)) where
  infixl 7 _∙_
  infix  4 _≈_
  field
    Carrier : Set c
    _≈_     : Rel Carrier ℓ
    _∙_     : Op₂ Carrier
    isMagma : IsMagma _≈_ _∙_

  open IsMagma isMagma public

  rawMagma : RawMagma _ _
  rawMagma = record { _≈_ = _≈_; _∙_ = _∙_ }

  open RawMagma rawMagma public
    using (_≉_)
\end{minted}
Above is the bundled version of \inline{IsMagma} structure. \inline{RawMagma} is
the raw version of the magma with only the operators and set. infix<l,r> denotes
the fixity and precedence of the operator. The operator with higher fixity binds
more strongly than an operator with a lower numeric value. \inline{using}
keyword is used to limit the imported components. When exporting the modules, we
may need to rename the fields to avoid having ambiguity. Keyword
\inline{renaming} is used to rename the fields.
\label{code:rename}
\begin{minted}[breaklines,samepage]{Agda}
  open IsMagma *-isMagma public
    using ()
    renaming
    ( ∙-congˡ  to *-congˡ
    ; ∙-congʳ  to *-congʳ
    )
\end{minted} 
We rename \inline{∙-congˡ}  to \inline{*-congˡ} and \inline{∙-congʳ}  to
\inline{*-congʳ} thus avoiding conflict with same elements exported by other
module.

\section{Calculational Proofs in Agda}
An proof is a sequence of steps that transform one expression into another using
a set of rules. Agda allows us to declare properties of functions and data types
that need to be verified by the compiler. \cite{kidney2020finiteness}.  

In the previous section, we have seen how to define natural number and addition
function on it. Now, we will write an inductive proof using pattern matching
that states that the addition of two natural numbers is commutative.

\begin{minted}[breaklines,samepage]{Agda}
comm : ∀ (m n : Nat) → m + n ≡ n + m
comm zero zero = refl
comm zero (suc n) = cong suc (comm zero n)
comm (suc m) n = cong suc (comm m n)
\end{minted}

In the above example, the proof \inline{comm zero zero} represents commutative
property where both \inline{m} and \inline{n} are \inline{zero}. The
\inline{refl} function is used to prove that two expressions are equal using the
reflexivity of equality. \inline{comm zero suc n} and \inline{suc m + n} are
reduced recursively until the base case is reached. The \inline{cong} function
is used to apply the inductive hypothesis to the successive \inline{suc}
constructors. This is just a simple example of proof, but Agda allows us to
express and verify more complex properties, such as type soundness, termination,
and correctness of algorithms.

In algebraic structure, consider the example to the proposition of the associative property x ∙ (y ∙ z)
= (x ∙ y) ∙ z  for a semigroup i.e., a Magma with associative property (x ∙ (y ∙
z) = (x ∙ y) ∙ z). The proof can be written in Agda as:
\begin{minted}[breaklines,samepage]{Agda}
x∙yz≈xy∙z : ∀ x y z → x ∙ (y ∙ z) ≈ (x ∙ y) ∙ z
x∙yz≈xy∙z x y z = begin 
  x ∙ (y ∙ z) ≈⟨ sym (assoc x y z) ⟩ 
  (x ∙ y) ∙ z ∎
\end{minted}
To make proofs more readable, people have tried to emulate textual proofs, for
example, by creating "begin" and "end" syntax. \inline{begin} indicates the start
of the proof. \inline{begin} is a function that relates two objects.
\begin{minted}{Agda}
begin_ : ∀ {x y} → x IsRelatedTo y → x ∼ y
begin relTo x∼y = x∼y
\end{minted}
\inline{IsRelatedTo} is a type defined to infer arguments even if the underlying equality
evaluates. Standard step to relation is defined as \inline{step-∼}.
\begin{minted}[breaklines,samepage]{Agda}
step-∼ : ∀ x {y z} → y IsRelatedTo z → x ∼ y → x IsRelatedTo z
step-∼ _ (relTo y∼z) x∼y = relTo (trans x∼y y∼z)
\end{minted}
similarly, step using equality is given as
\begin{minted}[breaklines,samepage]{Agda}
step-≈ = Base.step-∼
syntax step-≈ x y≈z x≈y = x ≈⟨ x≈y ⟩ y≈z
\end{minted}
The termination (i.e., QED) of the proof is given using \inline{_∎} that relates object to itself.
\begin{minted}[breaklines,samepage]{Agda}
_∎ : ∀ x → x IsRelatedTo x
x ∎ = relTo refl
\end{minted}
Agda supports quantifiers. Universal quantifier is denoted as \(\forall\) and
existential quantifier is denoted as \(\exists\).

